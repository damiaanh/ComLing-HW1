import string

class BigramModel:

    def __init__(self, tokens):
        self.tokens = tokens
        self.wordcount = {}
        self.totalwords = 0
        self.cleanlist = self.prepare_tokens(self.tokens)
        self.freqtable = self.calc_frequencies()

    def prepare_tokens(self, tokens):
        """
        Prepares the tokens generated by CorpusReader by removing punctuation,
        lower case all and add start and end markings.
        Returns a list of tokenized sentences.
        """
        STARTMARK = "<s>"
        ENDMARK = "</s>"
        cleanlist = []
        for sentence in tokens:
            cleansent = []
            cleansent.append(STARTMARK)
            for token in sentence:
                token.strip(string.punctuation)
                token.lower()
                if token is not "":     # Only continue for tokens that are not empty (due to removing punctuation)
                    if token in self.wordcount:  # Count words while looping over the text
                        self.wordcount[token] += 1
                    else:
                        self.wordcount[token] = 1
                    cleansent.append(token)
                    self.totalwords += 1
            cleansent.append(ENDMARK)
            cleanlist.append(cleansent)
        return cleanlist


    def count_bigrams(self, sentences):
        """
        Calculates frequencies for all bigrams in all sentences. returns a 3D-array
        where words are linked to frequencies.
        """
        bigramcount = {}
        for sentence in sentences:
            for word in sentence[:-1]: # Not looping over the last word ("</s>") since there is no second word
                if sentence[word, word+1] in bigramcount:
                    bigramcount[[word,word+1]] += 1
                else:
                    bigramcount[[word,word+1]] = 1
        return bigramcount

    def p_raw(self, w, w_n):
        pass

    def p_smooth(self,w, w_n):
        pass

    def successors(self, w):
        pass
    
    def perplexity(self, sent):
        pass


